# План фаз разработки CallAnnotate

Файл: `docs/development-phases.md`  
Версия: 2.0  
Дата: 27 июля 2025  

CallAnnotate — модульная система автоматической аннотации аудиозаписей. Каждая фаза — небольшая, измеримая итерация с чётким набором задач, критериев успешности и ожидаемых артефактов.

1. **Phase 1: REST API и файловая очередь**  
   Статус: выполнено  
   - Задачи:  
     - Реализовать эндпоинты `/health`, `/info`, `/jobs` (FastAPI).  
     - Организовать файловую очередь: папки `incoming`, `processing`, `completed`, `failed`, `archived`.  
     - Асинхронная обработка одного файла в фоне через `QueueManager`.  
     - Настроить Dockerfile и `docker-compose.yml`.  
     - Покрыть unit-тестами (coverage ≥ 80%).  
     - Включить CI (GitHub Actions) для сборки и pytest.  
   - Критерии готовности: REST-запросы возвращают ожидаемые статусы; файлы переходят по состояниям; все тесты проходят.

2. **Phase 2: WebSocket и real-time уведомления**  
   Статус: выполнено  
   - Задачи:  
     - WebSocket-эндпоинт `/ws/{client_id}` с поддержкой JSON-сообщений.  
     - Реализовать heartbeat (ping/pong) и автоматическое переподключение клиента.  
     - Ограничить размер сообщений (backpressure).  
     - Интеграционные тесты WebSocket (соединение, heartbeat, получение `status_update` и `result`).  
     - Обновить CI для запуска WebSocket-тестов.  
   - Критерии готовности: соединение надёжно, при переполнении клиент получает ошибку и соединение закрывается; тесты проходят.

3. **Phase 3: Базовая архитектура ML-модулей**  
   - Задачи:  
     1. Создать пакет `src/ml` и базовый абстрактный класс `MLProcessor` (методы `load_model()`, `process(input)`, `cleanup()`).  
     2. Определить конфиг-модель `config/models.yaml` с описанием путей и параметров моделей.  
     3. Разработать «заглушки» (mocks) для тестирования без реальных моделей.  
     4. Написать unit-тесты для интерфейса (coverage ≥ 90%).  
   - Критерии готовности: класс компилируется, конфиг парсится, mocks работают, тесты зелёные.

4. **Phase 4: Предобработка и диаризация**  
   - Задачи:  
     1. Реализовать `src/ml/preprocessing.py`: нормализация уровня, удаление шума (использовать sox или библиотеку).  
     2. Интегрировать pyannote/speaker-diarization в `src/ml/diarization.py`.  
     3. Написать unit-тесты на корректность сегментации аудио (набор тестовых WAV-файлов).  
     4. Расширить `QueueManager`: вызывать preprocessing → diarization перед транскрипцией.  
   - Критерии готовности: промежуточные файлы корректно создаются, сегменты соответствуют ожиданиям, тесты зелёные.

5. **Phase 5: ASR-модуль и потоковая транскрипция**  
   - Задачи:  
     1. Реализовать `src/ml/transcription.py` для OpenAI Whisper (batch и streaming API).  
     2. Добавить разбиение аудио на чанки (`src/streaming/audio_chunker.py`).  
     3. WebSocket: отправлять промежуточные транскрипты по мере обработки чанков.  
     4. Юнит-тесты для клиента-streaming (latency ≤ 3 с).  
   - Критерии готовности: транскрипция работает для целого файла и для чанков, streaming-результаты приходят быстро, тесты зелёные.

6. **Phase 6: Распознавание говорящих (Speaker Recognition)**  
   - Задачи:  
     1. В `src/ml/recognition.py` интегрировать ECAPA-TDNN (speechbrain).  
     2. Организовать загрузку и хранение эмбеддингов в папке `volume/models/embeddings`.  
     3. REST-эндпоинты для добавления/удаления «известных» голосов.  
     4. Написать unit-тесты точности распознавания (precision ≥ 85 %).  
   - Критерии готовности: распознавание корректно на тестовом сете, API возвращает `speaker_id` или `unknown`, тесты зелёные.

7. **Phase 7: Интеграция CardDAV-контактов**  
   - Задачи:  
     1. Реализовать `src/contacts/carddav_client.py` с асинхронным HTTP-клиентом.  
     2. Кэширование контактов в Redis/файле, fallback при недоступности сервера.  
     3. REST-эндпоинты: CRUD операций над контактами.  
     4. Интеграционные тесты с мок-CardDAV (pytest-aioresponses).  
   - Критерии готовности: контакты синхронизируются, кэш работает, CRUD проходит, тесты зелёные.

8. **Phase 8: Production-ready CI/CD и контейнеризация**  
    - Задачи:  
      1. Кросс-платформенная сборка Docker-образов (amd64, arm64).  
      2. Security scan зависимостей (Trivy, Dependabot).  
      3. Helm-charts для Kubernetes и документация по развёртыванию.  
      4. Performance- и load-тестирование в CI (coverage ≥ 90 %).  
      5. Автоматический rollback при неудачах (GitHub Actions).  
    - Критерии готовности: CI проходит все проверки, образы готовы, деплой документирован.

---
